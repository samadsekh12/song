<!doctype html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <title>Endless Bike Racer — One Page</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b1320;
      --road:#2b2f36;
      --lane:#3a3f46;
      --accent:#ffcc00;
      --white:#f7f7f7;
      --danger:#ff4d4f;
      --ui-bg: rgba(0,0,0,0.45);
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#041022 0%, #071428 60%);font-family:Inter, "Noto Sans Bengali", sans-serif;color:var(--white)}
    .wrap{max-width:980px;margin:18px auto;padding:12px;}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#111;cursor:pointer;font-weight:700}
    button.secondary{background:transparent;color:var(--white);border:1px solid rgba(255,255,255,0.08)}
    .ui{display:flex;gap:12px;align-items:center}
    .stat{background:var(--ui-bg);padding:8px 12px;border-radius:8px;font-weight:700}
    canvas{display:block;border-radius:12px;margin-top:12px;width:100%;height:520px;background:var(--road);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    footer{margin-top:12px;color:rgba(255,255,255,0.6);font-size:13px;text-align:center}
    /* responsive */
    @media (max-width:640px){canvas{height:420px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Endless Bike Racer (4 Lanes) — Score increases speed</h1>
      <div class="controls">
        <div class="ui">
          <div class="stat" id="score">Score: 0</div>
          <div class="stat" id="speed">Speed: 4</div>
        </div>
        <button id="startBtn">Start</button>
        <button id="pauseBtn" class="secondary">Pause</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
    </header>

    <canvas id="game"></canvas>

    <footer>Use Left / Right arrows to change lanes. Mobile: tap left/right half of canvas.</footer>
  </div>

  <script>
  /* -----------------------------
     Endless 4-lane bike racing game
     Single-file HTML/CSS/JS
     Basic mechanics:
       - 4 lanes horizontally
       - player occupies one lane (bike)
       - obstacles spawn ahead and move down (toward player)
       - score increments over time; every threshold increases speed
       - endless until collision
     Controls:
       - Left/Right arrows (desktop)
       - Tap left/right half (mobile)
     ----------------------------- */

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  // sizing
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.min(980, Math.max(360, rect.width)) * devicePixelRatio;
    canvas.height = (rect.height || (520)) * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }
  // set CSS height so boundingRect exists
  canvas.style.height = '520px';
  resize();
  window.addEventListener('resize', () => { resize(); });

  // Game variables
  const lanes = 4;
  let laneWidth;
  let world = {
    running: false,
    paused: false,
    score: 0,
    speed: 4,        // base speed (pixels per tick)
    spawnTimer: 0,
    spawnInterval: 90, // frames
    tick: 0,
    obstacles: [],
    lastTime: 0
  };

  // Player
  const player = {
    lane: 1,                   // 0..lanes-1; start in lane 1 (second lane)
    widthRatio: 0.55,
    height: 38,
    x: 0,
    y: 0
  };

  // Helpers
  function toPx(n){ return n; }

  function initLayout() {
    const cssW = canvas.getBoundingClientRect().width;
    laneWidth = cssW / lanes;
    player.x = player.lane * laneWidth + laneWidth/2 - (laneWidth*player.widthRatio)/2;
    player.y = canvas.getBoundingClientRect().height - player.height - 28;
  }

  initLayout();

  // spawn obstacle
  function spawnObstacle() {
    const lane = Math.floor(Math.random()*lanes);
    const width = laneWidth * (0.5 + Math.random()*0.35);
    const height = 28 + Math.random()*28;
    const x = lane * laneWidth + laneWidth/2 - width/2;
    const y = -height - (Math.random()*80);
    const type = Math.random() < 0.12 ? 'truck' : 'car';
    world.obstacles.push({lane, x, y, width, height, type, marked:false});
  }

  // draw road & lanes
  function drawRoad() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    // road background
    ctx.fillStyle = '#23272b';
    ctx.fillRect(0, 0, w, h);
    // lane separators (dashed)
    ctx.strokeStyle = '#3b3f44';
    ctx.lineWidth = 2;
    for(let i=1;i<lanes;i++){
      const x = i*laneWidth;
      // dashed middle
      ctx.setLineDash([14,12]);
      ctx.beginPath();
      ctx.moveTo(x, 8);
      ctx.lineTo(x, h-8);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    // road side stripes
    ctx.fillStyle = '#1b1f23';
    ctx.fillRect(0,0, w*0.02, h);
    ctx.fillRect(w - w*0.02,0, w*0.02, h);
  }

  // draw player (bike simple)
  function drawPlayer() {
    const w = laneWidth * player.widthRatio;
    const h = player.height;
    const px = player.lane * laneWidth + laneWidth/2 - w/2;
    player.x = px;
    // bike body
    ctx.fillStyle = '#ffcc00';
    roundRect(ctx, px, player.y, w, h, 8, true, false);
    // wheels
    ctx.fillStyle = '#111';
    const wheelR = 6;
    ctx.beginPath(); ctx.arc(px+12, player.y + h, wheelR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(px + w-12, player.y + h, wheelR, 0, Math.PI*2); ctx.fill();
  }

  // draw obstacles
  function drawObstacles() {
    world.obstacles.forEach(o => {
      if(o.type === 'truck') ctx.fillStyle = '#cc3333';
      else ctx.fillStyle = '#3498db';
      roundRect(ctx, o.x, o.y, o.width, o.height, 6, true, false);
      // small window
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(o.x + 8, o.y + 6, Math.max(12, o.width - 16), 8);
    });
  }

  // rounded rect helper
  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if(fill){ ctx.fill(); }
    if(stroke){ ctx.stroke(); }
  }

  // update world
  function update(dt) {
    if(!world.running || world.paused) return;
    world.tick++;
    // move obstacles
    const speed = world.speed;
    world.obstacles.forEach(o => { o.y += speed * (dt/16); });
    // remove passed obstacles (and increase score)
    for(let i = world.obstacles.length-1; i>=0; i--){
      const o = world.obstacles[i];
      if(o.y > canvas.getBoundingClientRect().height + 60) {
        world.obstacles.splice(i,1);
        world.score += 5; // reward for passing obstacle
        updateUI();
      }
    }

    // spawn logic
    world.spawnTimer++;
    if(world.spawnTimer >= Math.max(16, world.spawnInterval - Math.floor(world.score/50))) {
      spawnObstacle();
      world.spawnTimer = 0;
    }

    // continuous score (distance)
    if(world.tick % 6 === 0){
      world.score += 1;
      updateUI();
    }

    // increase speed per score thresholds
    const newSpeed = 4 + Math.floor(world.score / 60);
    if(newSpeed !== world.speed){
      world.speed = newSpeed;
      updateUI();
    }

    // collision check
    for(const o of world.obstacles) {
      if(collide(o, player)){
        endGame();
        break;
      }
    }
  }

  // collision detection (AABB simplified)
  function collide(obj, player) {
    const px = player.x;
    const py = player.y;
    const pw = laneWidth * player.widthRatio;
    const ph = player.height;
    const ox = obj.x;
    const oy = obj.y;
    const ow = obj.width;
    const oh = obj.height;
    return !(px + pw < ox + 6 || px > ox + ow - 6 || py + ph < oy + 6 || py > oy + oh - 6);
  }

  // draw loop
  function draw() {
    // clear
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    drawRoad();
    drawObstacles();
    drawPlayer();

    if(!world.running){
      // overlay start hint
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#fff';
      ctx.font = '18px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Press Start to play', w/2, h/2 - 8);
      ctx.font = '13px Inter, sans-serif';
      ctx.fillText('Use Left / Right arrows or tap sides (mobile) to change lanes', w/2, h/2 + 14);
    }
  }

  // main loop (rAF)
  function loop(time) {
    if(!world.lastTime) world.lastTime = time;
    const dt = Math.min(40, time - world.lastTime);
    world.lastTime = time;
    if(world.running && !world.paused){
      update(dt);
    }
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // UI updates
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  function updateUI(){
    scoreEl.textContent = 'Score: ' + world.score;
    speedEl.textContent = 'Speed: ' + world.speed;
  }

  // controls
  document.getElementById('startBtn').addEventListener('click', () => {
    if(!world.running){
      startGame();
      document.getElementById('startBtn').textContent = 'Restart';
    } else {
      resetGame();
      startGame();
    }
  });
  document.getElementById('pauseBtn').addEventListener('click', (e) => {
    world.paused = !world.paused;
    e.target.textContent = world.paused ? 'Resume' : 'Pause';
  });
  document.getElementById('resetBtn').addEventListener('click', () => {
    resetGame();
  });

  function startGame(){
    world.running = true;
    world.paused = false;
    world.lastTime = 0;
    world.tick = 0;
    world.obstacles = [];
    world.spawnTimer = 0;
    // keep current lane
    initLayout();
  }

  function resetGame(){
    world.running = false;
    world.paused = false;
    world.score = 0;
    world.speed = 4;
    world.obstacles = [];
    player.lane = 1;
    updateUI();
    document.getElementById('startBtn').textContent = 'Start';
    document.getElementById('pauseBtn').textContent = 'Pause';
  }

  function endGame(){
    world.running = false;
    // show crash effect
    flashGame();
    // mark final UI
    updateUI();
    // simple overlay message
    setTimeout(()=> {
      alert('Game Over! তোমার স্কোর: ' + world.score);
    }, 60);
  }

  function flashGame(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.save();
    ctx.fillStyle = 'rgba(255,0,0,0.12)';
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  // input handlers
  window.addEventListener('keydown', (e) => {
    if(!world.running) return;
    if(e.key === 'ArrowLeft') changeLane(-1);
    if(e.key === 'ArrowRight') changeLane(1);
  });

  // touch controls: tap left/right half to change lane
  canvas.addEventListener('touchstart', (e) => {
    if(!world.running) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    if(x < rect.width / 2) changeLane(-1);
    else changeLane(1);
  });

  // click halves for desktop
  canvas.addEventListener('click', (e) => {
    if(!world.running) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    if(x < rect.width / 2) changeLane(-1);
    else changeLane(1);
  });

  function changeLane(dir){
    const newLane = Math.max(0, Math.min(lanes-1, player.lane + dir));
    if(newLane !== player.lane){
      player.lane = newLane;
    }
  }

  // initialize UI values
  updateUI();
  // set initial layout on load
  window.addEventListener('load', () => {
    initLayout();
    // draw once
    draw();
  });

  </script>
</body>
</html>
```
